
:toc:

:icons: font

:path: 分布式/
:imagesdir: ../image/

// 只有book调用的时候才会走到这里
ifdef::rootpath[]
:imagesdir: {rootpath}{path}{imagesdir}
endif::rootpath[]

== 分布式常见知识点

=== 分布式系统的事务处理

在实际生产中，随着业务的组件扩大使用单个服务器提供数据服务时，常常会遇到以下问题：

- 一台服务器的性能不足以提供足够的能力服务于所有的网络请求
- 服务器可能停机导致当前的服务不可用

所有的问题都指向一个结论那就是需要加入更多的机器来分担性能上的问题，以及单点故障的问题。通常在实际生产中采用以下手段来扩展数据服务：

- 数据分区：就是把数据分块放到不同的服务器上(比与微观的缓存cache way和hash桶等类似)
- 数据镜像：所有服务端都有相同的数据，提供相同的服务。

使用数据分区我们无法解决数据丢失的问题，单台服务器出现问题时还是会有部分数据丢失。因此、想要数据的高可用必须通过数据镜像，通过数据的冗余存储来实现数据高可用。
但是加入多个机器会让数据处理变的复杂，尤其是跨服务器事务处理，跨服务器事务处理牵涉到数据一致性，常用来保持数据一致性的算法是paxos和raft。

在保持数据一致性的时候我们需要考虑以下几种情况：

- 容灾：要有多个节点，保证数据不丢失
- 数据一致性：事务处理
- 性能：吞吐量足够、响应足够快

简单的来说，容灾就是让数据高可用，保证数据有多份，一份数据不能使用时可以通过数据副本进行恢复；要保存多份数据，就会存在数据一致性问题，这时就需要使用数据一致算法保证多份数据更新时的一致性；要保存多份数据，还要好保证多份数据一致性又会导致性能下降，因此在设计一致性算法时还要兼顾性能，保证性能能够满足要求。

软件开发不能大的小的都要，必须懂得取舍，鱼与熊掌不可兼得在软件开发中绝对适用。

==== 一致性模型

说起数据一致性来说，简单说有三种类型（细分的话，还有很多一致性模型，如：顺序一致性，FIFO一致性，会话一致性，单读一致性，单写一致性，但为了本文的简单易读，我只说下面三种）：

- Weak弱一致性：当你协议一个值，读操作在副本上肯能读出来，也可能读不出来。比如某些cache系统，或者是搜索引擎中的特例-百度搜索引擎(作恶)
- Eventually 最终一致性：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google搜索引擎这样的系统。
- Strong 强一致性：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table，etcd都是强一致性的。

从这三种一致性模型来说，我们我们可以看到，Weak和Eventually一般来说是异步冗余的，而strong一般来说是同步冗余的，异步的通常意味着更好的性能，但是也意味着更加复杂的状态同步控制，同步更加简单，但是简单的同时是以牺牲性能为代价的。

*Master-Slave*

在这种结构中slave一般是master的备份，在这种设计中一般：

1. 读写请求都是由master负责
2. 写请求由Master负责写入，并同步到slave上

参考，etcd，zk等(有少许不同)，的集群设计。

*Master-Master*

Master-Master又叫多主模式，是指一个系统中有一个或者多个master，每个master都提供Read-write服务，这种服务一般是master-slave的加强版，数据同步一般是通过master之间的异步完成的，所以是最终一致性的一致性模型。使用Master-Master的好处就是一台服务器挂了另外一天服务器能正常进行服务-

但是当多个Master同时进行数据修改时，对于Master-Master这种结构就是灾难性的，对于这种情况SVN采取的解决策略是让用户自己来解决。

https://en.wikipedia.org/wiki/Vector_clock[vector_clock]

*Two/Three Phase Commit*

这个协议的缩写又叫做2PC，中文叫两阶段提交。在分布式系统中，每个节点虽然可以知道自己操作的成功与失败，却无法知晓其他节点的成功与失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个节点来掌控所有节点，并最终由该节点指示其他节点是否真正的进行提交。

[red]#第一阶段#

- 协调参与者进行事务操作，并根据协调结果来决定事务是否能够提交操作
- 各个参与者开始为资源申请资源，执行必要的操作，并在事务内准备完成undo/redo等操作
- 参与者响应该协调者，根据自身资源执行状况反馈给协调者该事务是否可以提交或者不可以提交

[red]#第二阶段#

如果所有参与者或者超过半数的参与者(etcd)回应可以进行提交则进行事务提交，如果有一个参与者恢复拒绝或者etcd中超过半数的参与者恢复决绝提交则进行事务回滚

image::image-2023-06-09-11-09-19-424.png[]

从图中可以看到，2PC第一阶段其实就是进行Vote(投票)，第二阶段根据算法来决定事务是否可以提交，这种模式也是一种强一致性算法。前面讲的Master-slave也是强一致性算法，只不过这里的2PC算法更加保守一些，会根据投票结果来决定是否执行提交操作，多了一层保障。当然两阶段的2PC只是最简单的两阶段提交操作，根据需要两阶段可以进行嵌套，嵌套之后你可以得到A->B->C->D->E->F->G->H等等，这种嵌套的两阶段，任何一个阶段出现问题都需要进行反向操作保证没有资源泄露。因此、进行来那个阶段操作起来很复杂，现在很多workflow都会借鉴这个2PC这个算法，使用try-confirm的流程来确保整个流程能够成功完成。

1）牧师分别问新郎和新娘：你是否愿意……不管生老病死……（询问阶段）

2）当新郎和新娘都回答愿意后（锁定一生的资源），牧师就会说：我宣布你们……（事务提交）

但是两阶段还虽然已经算是复杂了，还是存在问题，如果在第二阶段，参与者收不到协调者的commit/fallback怎么办？一直卡在待提交状态？也就是说第一阶段完成后，参与者在第二阶段没有收到决策，那么数据结点会进入不知所措的状态，这个状态会block住整个事务。也就是说，协调者Coordinator对于事务的完成非常重要，Coordinator的可用性是个关键。 因些，我们引入三段提交(Three-phase commit protocol)，三段提交在Wikipedia上的描述如下，他把二段提交的第一个段break成了两段：询问，然后再锁资源。最后真正提交。三段提交的示意图如下：

image::image-2023-06-09-11-36-59-528.png[]

其核心理念就是在询问的时候并不锁定资源，除非所有人都同意了，才开始锁定资源。因为在提交之前已经收到了所有参与者同意修改回馈，所以有理由相信成功提交的概率很大，这样一来就能大大降低参与则的未知状态的概率。

> 注意图中的虚线，那些F,T是Failuer或Timeout，其中的：状态含义是 q – Query，a – Abort，w – Wait，p – PreCommit，c – Commit

image::image-2023-06-09-13-47-49-222.png[]


https://en.wikipedia.org/wiki/Two_Generals'_Problem[Two Generals Problem]两将军问题是这么一个思维性实验问题： 有两支军队，它们分别有一位将军领导，现在准备攻击一座修筑了防御工事的城市。这两支军队都驻扎在那座城市的附近，分占一座山头。一道山谷把两座山分隔开来，并且两位将军唯一的通信方式就是派各自的信使来往于山谷两边。不幸的是，这个山谷已经被那座城市的保卫者占领，并且存在一种可能，那就是任何被派出的信使通过山谷是会被捕。 请注意，虽然两位将军已经就攻击那座城市达成共识，但在他们各自占领山头阵地之前，并没有就进攻时间达成共识。两位将军必须让自己的军队同时进攻城市才能取得成功。因此，他们必须互相沟通，以确定一个时间来攻击，并同意就在那时攻击。如果只有一个将军进行攻击，那么这将是一个灾难性的失败。 这个思维实验就包括考虑他们如何去做这件事情。

推荐paxos算法和raft算法。

https://en.wikipedia.org/wiki/Paxos_(computer_science)[paxos] +
https://en.wikipedia.org/wiki/Raft_(algorithm)[raft_algorithm] +
https://www.ibm.com/topics/etcd[etcd_algorithm/raft]


=== 消息中心分布式存储实现




=== 集群间同步



=== 分布式可靠性



服务器可靠性的“几个9”的评级是指系统可用性的一种度量方式，通常用来描述系统在一年中的正常运行时间比例。这个指标对于在线服务、数据中心以及其他关键业务系统尤为重要，因为它直接关系到用户体验和业务连续性。以下是不同等级的可用性和它们对应的一年内的停机时间：

- **99.999%（五个9）**：每年停机时间不超过5.26秒。这是极高的可用性标准，通常只有电信级网络和一些金融交易系统会追求这样的目标。
- **99.99%（四个9）**：每年停机时间不超过52.6秒。这是一个非常高的标准，适用于对可靠性要求非常高的系统。
- **99.9%（三个9）**：每年停机时间不超过8.76小时。这已经是较高的标准，适合大多数企业级应用。
- **99%（两个9）**：每年停机时间不超过3.65天。虽然这个标准相对较低，但对于一些非关键任务的应用可能是可接受的。

实现高可用性的方法包括但不限于：

- **冗余设计**：确保关键组件有备份，如双电源、多网络接口、多个存储设备等。
- **负载均衡**：通过分散请求到多个服务器上，避免单点故障。
- **故障转移机制**：当主系统出现故障时，能够自动切换到备用系统，保证服务不间断。
- **定期维护和更新**：预防性地进行软件和硬件的更新，减少因过时技术导致的问题。
- **监控与报警系统**：实时监控系统状态，及时发现并解决问题。

不同的企业和组织根据自己的业务需求和预算，会选择不同的可用性目标。通常，越高可用性的系统，其建设和维护成本也越高。





































