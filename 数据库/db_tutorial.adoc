
:toc:

:icons: font

// 保证所有的目录层级都可以正常显示图片
:path: 数据库/
:imagesdir: ../image/
:srcdir: ../src


// 只有book调用的时候才会走到这里
ifdef::rootpath[]
:imagesdir: {rootpath}{path}{imagesdir}
:srcdir: {rootpath}../src/
endif::rootpath[]

ifndef::rootpath[]
:rootpath: ../
:srcdir: {rootpath}{path}../src/
endif::rootpath[]


== 数据库教程

- 存储数据的格式是怎样的(在内存和磁盘上)
- 什么时候存储的数据会从内存转移到磁盘上
- 为什么数据库中一个table中只能有一个主键
- 事务操作中回滚是如何实现的？
- 索引的格式是什么
- 全表扫描什么时候以及如何完成的
- 预声明语句是按照什么格式存储的？

总之一句话，数据库是如何工作的？

=== 简单的REPL(read-execute-print loop)
==== Sqlite

这个教程就是对sqlite的模仿，所以有必要先了解一下sqlite的组成，sqlite分为前端部分和后端部分。

前端部分主要完成一些列组件检索或修改数据，主要如下：

- tokenizer
- parser
- code generator

前端接收的是sql语句，输出的是sqlite虚拟机字节码，后端组成如下：

- virtual machine
- B-tree
- pager
- os interface

==== 一个简单的REPL
当你使用命令行启动sqlite时，sqlite会开始一个read-execute-print loop
[source, SQL]
----
[xxx@localhost]$sqlite3
sqlite> create table users (id int, username varchar(255), email varchar(255));
sqlite> .tables
users
sqlite> .exit
----
为了实现和sqlite同样的效果，我们需要实现一个循环，在循环里面打印提示，并且持续接收输入然后处理输入

[source, c]
.dm_main process input
----
int main(int argc, char* argv[]) {
    InputBuffer* input_buffer = new_input_buffer();
    while (true) {
        print_prompt();
        read_input(input_buffer);

        if (strcmp(input_buffer->buffer, ".exit") == 0) {
            close_input_buffer(input_buffer);
            exit(EXIT_SUCCESS);
        } else {
            printf("Unrecognized command '%s'.\n", input_buffer->buffer);
        }
    }
}
----

在这里定义一个 `InputBuffer` 用来封装getline获取的内容

[source, cpp]
----
typedef struct {
  char* buffer;
  size_t buffer_length;
  ssize_t input_length;
} InputBuffer;

InputBuffer* new_input_buffer() {
  InputBuffer* input_buffer = (InputBuffer*)malloc(sizeof(InputBuffer));
  input_buffer->buffer = NULL;
  input_buffer->buffer_length = 0;
  input_buffer->input_length = 0;

  return input_buffer;
}
----

接下来，定义一个print_prompt来给用户打印提示，每次调用读取之前我们都会调用一下这个函数

[source, cpp]
----
void print_prompt() { printf("db > "); }
----

使用getline读取用户的输入，但是这里需要注意的是getline官方给出的说明：
也就是说，当传入的是一个地址指向的内容是nullptr的时候，getline会默认申请一段内存，在使用结束的时候需要用户自行进行释放。否则或存在内存泄露，当然如果有必要用户可以自己根据需要自行申请内存，只要传入的指针地址不是nullptr那么getline就不会在申请内存

If *lineptr is NULL, then getline() will allocate a buffer for storing the line, which should be freed by the user program.   (In  this  case,
the value in *n is ignored.)

因此需要定义一个配套的内存释放函数
[source, cpp]
----
ssize_t getline(char **lineptr, size_t *n, FILE *stream);

void read_input(InputBuffer* input_buffer) {
  ssize_t bytes_read =
      getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);

  if (bytes_read <= 0) {
    printf("Error reading input\n");
    exit(EXIT_FAILURE);
  }

  // Ignore trailing newline
  input_buffer->input_length = bytes_read - 1;
  input_buffer->buffer[bytes_read - 1] = 0;
}

// 配套内存释放函数
void close_input_buffer(InputBuffer* input_buffer) {
    free(input_buffer->buffer);
    free(input_buffer);
}
----

最后我们只需要在循环中挨个执行输入的指令即可，全部代码如下：

[source, cpp]
----

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char* buffer;
    size_t buffer_length;
    ssize_t input_length;
} InputBuffer;

InputBuffer* new_input_buffer() {
    InputBuffer* input_buffer = (InputBuffer*)malloc(sizeof(InputBuffer));
    input_buffer->buffer = NULL;
    input_buffer->buffer_length = 0;
    input_buffer->input_length = 0;

    return input_buffer;
}

void print_prompt() { printf("db > "); }

void read_input(InputBuffer* input_buffer) {
    //If *lineptr is NULL, then getline() will allocate a buffer for storing the line, which should be freed by the user program
    ssize_t bytes_read =
            getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);

    if (bytes_read <= 0) {
        printf("Error reading input\n");
        exit(EXIT_FAILURE);
    }

    // Ignore trailing newline
    input_buffer->input_length = bytes_read - 1;
    input_buffer->buffer[bytes_read - 1] = 0;
}

void close_input_buffer(InputBuffer* input_buffer) {
    free(input_buffer->buffer);
    free(input_buffer);
}

int main(int argc, char* argv[]) {
    InputBuffer* input_buffer = new_input_buffer();
    while (true) {
        print_prompt();
        read_input(input_buffer);

        if (strcmp(input_buffer->buffer, ".exit") == 0) {
            close_input_buffer(input_buffer);
            exit(EXIT_SUCCESS);
        } else {
            printf("Unrecognized command '%s'.\n", input_buffer->buffer);
        }
    }
}
----

执行过程如下：

因为这里只实现了.exit这个指令，所以在执行过程中也只会响应这一个指令
[source, SQL]
----
$./a.out
db > .tables
Unrecognized command '.tables'.
db > .exit
----

=== 世界上最简单的SQL编译器和虚拟机

这里目的是模仿sqlite，那sqlite的前端实现了SQL的编译-解析字符串并且输出内部展现形式-字节码
这些字节码会传输给虚拟机，虚拟机会执行这些字节码，具体的可以参考sqlite架构： https://www.sqlite.org/arch.html[sqlite arch]

将整个数据操作过程分隔成两个部分有两个好处：

- 减少每个部分的复杂度
- 允许将编译的字节码缓存以提高性能

为了实现这些我们可以对main进行如下改造

some main code


像.exit这样的Non-SQL声明我们称之为 `meta-command`，这些指令的特点就是所有指令都是使用.开头，因此我们可以根据是否.开头来将这些指令和正常的SQL指令进行区分处理。

> meta-元，是抽象的抽象，就像模板一样被称为元编程，编程本身就是对具体事务的抽象，模板是对抽象代码的进一步抽象，因此称模板编程为元编程。

接下来我们添加一个步骤将输入行转换为语句的内部表示形式，这是一个粗糙的sqlite前端

最后我们将上述前端处理之后的声明放入execute_statement，这个函数将会最终用来实现虚拟机的功能

do_meta_command接口只是对现有函数的一些简单封装，并且预留足够的空间方便添加更多的指令

[source, cpp]
.do_meta_command example
----
MetaCommandResult do_meta_command(InputBuffer* input_buffer) {
  if (strcmp(input_buffer->buffer, ".exit") == 0) {
    exit(EXIT_SUCCESS);
  } else {
    return META_COMMAND_UNRECOGNIZED_COMMAND;
  }
}
----

目前预声明语句只包含了两种可能的值，后期会进行扩展
[source, cpp]
----
typedef enum { STATEMENT_INSERT, STATEMENT_SELECT } StatementType;

typedef struct {
  StatementType type;
} Statement;
----

添加prepare_statement(SQL compiler)，但是目前只能处理两个指令

[source, cpp]
----
PrepareResult prepare_statement(InputBuffer* input_buffer,
                                Statement* statement) {
  if (strncmp(input_buffer->buffer, "insert", 6) == 0) {
    statement->type = STATEMENT_INSERT;
    return PREPARE_SUCCESS;
  }
  if (strcmp(input_buffer->buffer, "select") == 0) {
    statement->type = STATEMENT_SELECT;
    return PREPARE_SUCCESS;
  }

  return PREPARE_UNRECOGNIZED_STATEMENT;
}
----

最后让我们来实现执行的步骤

[source, cpp]
----
void execute_statement(Statement* statement) {
  switch (statement->type) {
    case (STATEMENT_INSERT):
      printf("This is where we would do an insert.\n");
      break;
    case (STATEMENT_SELECT):
      printf("This is where we would do a select.\n");
      break;
  }
}
----

这里实现知识搭建一些框架而已，真正的功能还没有实现，因此没有任何的错误处理等功能，具体的执行效果如下：

[source, SQL]
----
$./a.out
db > insert foo bar
This is where we would do an insert.
Executed.
db > delete foo
Unrecognized keyword at start of 'delete foo'.
db > select
This is where we would do a select.
Executed.
db > .tables
Unrecognized command '.tables'
db > .exit
----

现在数据库代码正在组件成型，如果能存储一些数据是不是就更加好了？在下一章节中我们将会实现insert和select，创造出一个最为糟糕的数据库存储实现，下面是代码diff的提交实现记录

