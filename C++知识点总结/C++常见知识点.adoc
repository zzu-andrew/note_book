
:toc:
== C++常见知识点总结
=== 语言类
==== 1. 某文件中定义的静态全局变量(静态外部变量(函数外部定义))其作用域是？
本文件，静态全局变量限制了其作用域，导致该变量只能在其所在的源文件有效。正是因为作用域局限于一个源文件内，因此可以避免其他源文件中同名变量引起的错误。如果当前源文件已经有同名静态变量，会优先使用静态变量。

==== 2. 通常使用__plusplus来判断一段程序是使用C++编译器编译的还是使用C编译器编译的
[source, cpp]
----
#ifdef __cplusplus
// C++
#else
//C
#endif
----
==== 3. C++函数中值的传递方式有哪几种，以及相互之间的区别
C++函数有三种传递方式：值传递、指针传递和引用传递
- 指针有自己的内存空间，引用知识一个别名
- sizeof计算指针的大小为4,而引用的大小为对象的大小
- 可以用 const指针但是不能有 const引用
[source, cpp]
----
int * const data = &dataSize;   // 可以有const指针
int & const data = dataSize;    // 但是引用不能是const的， 但是别名可以定义成const，其实这一切都是因为引用只是值得别名
const & int data = dataSize;   // 引用的别名是可以定义为const的
----
- 指针可以被初始化为
nullptr，但是引用必须被初始化，且必须是一个已有对象的引用
- 指针可以一有多级指针(**p)，而引用只能有一级

==== 4. new在C++中是？
关键字和运算符，
malloc是库函数，不在编译器控制范围之内；
new是运算符，在编译器控制范围之内；调用
malloc时，从堆中申请内存；调用
new时，从堆中申请内存并为内存调用构造函数。
C++程序执行时将内存大方向分为4个区域：
- 代码区域：存放函数体的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
- 堆区：由程序员分配和释放，若程序员不释放程序结束时由操作系统回收

==== 5. 多态的作用以及产生条件
多态是指不同的子类在继承父类后分别都重写覆盖了父类的方法，即父类同一个方法，在继承的子类中表现出不同的形式。因此可以实现调用同一函数能产生不同的行为
产生条件：

- 调用函数的对象必须是指针或者引用
- 被调用的函数必须是虚函数，且完成了虚函数的重写

作用：
 1. 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用
 2. 接口重用

==== 6. 多态类的虚函数表是Compile-Time，还是Run-Time时建立的？
虚函数在编译期间就建立了，各个虚函数在编译时组织成一个虚函数地址数组，而对象的隐藏成员-虚函数表指针是在运行期间，也就是构造函数被调用时进行初始化的，这是实现多态的关键

==== 7. 面向对象的三个基本特征，并简单叙述
-  封装，将客观事物抽象成类，每个类对自身的数据和方法实行protection(private, protected, public)
-  广义的继承有三种实现形式：实现继承(指使用基类的属性和方法而无需额外的编码能力)、可视继承(子窗体使用父窗体的外观和实现代码)、接口继承(仅使用属性和方法，实现滞后子类实现)。前两种(类继承)和后一种(接口继承)构成了功能复用的两种方式。
-  多态：允许将子类类型的指针赋值给父类类型的指针(使用父类类型引用子类对象)
-  main函数执行之前还会执行什么代码？
全局对象的构造函数会在main函数执行之前执行

[source, cpp]
----
using namespace std;

 class B {
 public:
     B() {
         cout << "Construct B " << endl;
     }
 };

 B b;

 int main(int argc, char* argv[]) {
     cout << "main Run" << endl;
     return 0;
 }
----

==== 9. 内存分配的方式有几种？
- 静态存储区域分配，内存在程序编译的时候就已经分配好了，这块内存在程序的整个运行期间都存在。例如全局变量，静态局部变量。
- 在栈上创建，在执行函数时，函数局部变量的存储单元可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内值于处理器的指令集中，效率很高但是分配的内存容量有限-普通的局部变量。
- 从堆上分配，也称为动态内存分配。程序在运行的时候采用malloc或new申请任意多少内存，程序员自己负责在任何时候free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活但是问题最多

==== 10. 引用和指针有什么区别？
- 引用必须被初始化，指针不必
- 引用初始化后不能被改变，指针可以改变所指的对象
- 不存在指向空值的引用，但是存在指向空值的指针

==== 11. C++是不是类型安全的？
不是， 类型的指针可以强制转换类型，类型之间也是可以强制转换

==== 12. volatile作用
1. volatile关键词的第一个特性：易变性。所谓的易变性，在汇编层面反应出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。
2. volatile关键词的第二个特性：不可优化特性，volatile告诉编译器不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令一定会被执行。
3. volatile关键词第三个特性：顺序性。能够保证volatile变量间的顺序行，编译器不会进行乱序优化。
但是当volatile变量于非volatile变量之间进行操作时，是有可能被编译器交换顺序的。只是volatile变量之间进行操作不会被编译器交换顺序。哪怕你把所有的变量都声明成volatile变量，哪怕你杜绝编译器的乱序优化，这也只能够保证生成的汇编代码不是乱序的，CPU仍然可能进行乱序执行指令，导致程序依赖的逻辑出错，volatile对此是无能为力的。这个时候要想保证内存交换的顺序就要使用到内存屏障技术了，具体的实现可以参考： C++内存模型和原子类型操作

==== 13. static关键字的作用
static无论在C还是在C++语言里面都可以永爱控制存储方式和可见性

- 修饰局部变量:

一般情况下局部变量都是放到栈上的，在语句块结束的时候变量的生命周期也就结束了。但是如果给局部变量添加上static进行修饰的话，该变量便存放到了静态数据区域，其生命周期一直会延续到整个程序结束。需要注意一点的是，使用static声明的局部变量只是改变了声明周期，其作用域还是局部的，只是在该语句块中可见，作用域也仅限于该语句块。

- 修饰全局变量

全局变量可以通过extern在整个工程中可见，但是经过static修饰过的全局变量就只能本源文件中可见

- 修饰函数

static修饰的函数(C语言中)，情况和修饰全局变量大同小异，就是改变了函数的作用域
- C++中的static
如果使用static修饰C++类中的函数，则说明该函数不属于该类的任何特定对象；如果对类中某个变量进行修饰，表示该变量为类以及其所有的对象所有。它们在存储空间中都只存在一个副本，可以通过类或者对象去调用。

==== const含义及其实现机制

const可以用来限定特定变量，以通知编译器该变量不可被修改。要习惯使用const，这样可以避免在函数中修改某些不应该修改的变量。
const的在不同场景的中的表现有些不同。

- const修饰基本数据类型































https://baijiahao.baidu.com/s?id=1718109965042627128&wfr=spider&for=pc



this指针是右值
虚函数也能被inline修饰，只是当虚函数实现多态时就算使用了inline关键字照样不会被内联





