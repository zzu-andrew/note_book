## C++常见知识点总结



## 语言类

### 1. 某文件中定义的静态全局变量(静态外部变量(函数外部定义))其作用域是？

本文件，静态全局变量限制了其作用域，导致该变量只能在其所在的源文件有效。正是因为作用域局限于一个源文件内，因此可以避免其他源文件中同名变量引起的错误。如果当前源文件已经有同名静态变量，会优先使用静态变量。

### 2. 通常使用`__plusplus`来判断一段程序是使用C++编译器编译的还是使用C编译器编译的

```cpp
#ifdef __cplusplus
  // C++
#else
 //C
#endif
```

### 3. C++函数中值的传递方式有哪几种，以及相互之间的区别

C++函数有三种传递方式：值传递、指针传递和引用传递

- 指针有自己的内存空间，引用知识一个别名
- `sizeof`计算指针的大小为4,而引用的大小为对象的大小
- 可以用`const`指针但是不能有`const`引用

```cpp
int * const data = &dataSize;   // 可以有const指针
int & const data = dataSize;    // 但是引用不能是const的， 但是别名可以定义成const，其实这一切都是因为引用只是值得别名
const & int data = dataSize;   // 引用的别名是可以定义为const的
```

- 指针可以被初始化为`nullptr`，但是引用必须被初始化，且必须是一个已有对象的引用
- 指针可以一有多级指针(**p)，而引用只能有一级

### 4. new在C++中是？

关键字和运算符，`malloc`是库函数，不在编译器控制范围之内；`new`是运算符，在编译器控制范围之内；调用`malloc`时，从堆中申请内存；调用`new`时，从堆中申请内存并为内存调用构造函数。

C++程序执行时将内存大方向分为4个区域：

- 代码区域：存放函数体的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
- 堆区：由程序员分配和释放，若程序员不释放程序结束时由操作系统回收

### 5. 多态的作用以及产生条件

多态是指不同的子类在继承父类后分别都重写覆盖了父类的方法，即父类同一个方法，在继承的子类中表现出不同的形式。因此可以实现调用同一函数能产生不同的行为

产生条件：

- 调用函数的对象必须是指针或者引用
- 被调用的函数必须是虚函数，且完成了虚函数的重写

作用：

1. 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用
2. 接口重用

### 6. 多态类的虚函数表是Compile-Time，还是Run-Time时建立的？

虚函数在编译期间就建立了，各个虚函数在编译时组织成一个虚函数地址数组，而对象的隐藏成员-虚函数表指针是在运行期间，也就是构造函数被调用时进行初始化的，这是实现多态的关键

### 7. 面向对象的三个基本特征，兵简单叙述

1. 封装，将客观事物抽象成类，每个类对自身的数据和方法实行protection(private, protected, public)
2. 广义的继承有三种实现形式：实现继承(指使用基类的属性和方法而无需额外的编码能力)、可视继承(子窗体使用父窗体的外观和实现代码)、接口继承(仅使用属性和方法，实现滞后子类实现)。前两种(类继承)和后一种(接口继承)构成了功能复用的两种方式。
3. 多态：允许将子类类型的指针赋值给父类类型的指针(使用父类类型引用子类对象)

### 8. main函数执行之前还会执行什么代码？

全局对象的构造函数会在main函数执行之前执行

```cpp
using namespace std;

class B {
public:
    B() {
        cout << "Construct B " << endl;
    }
};

B b;

int main(int argc, char* argv[]) {
    cout << "main Run" << endl;
    return 0;
}
```

### 9. 内存分配的方式有几种？

- 静态存储区域分配，内存在程序编译的时候就已经分配好了，这块内存在程序的整个运行期间都存在。例如全局变量，静态局部变量。
- 在栈上创建，在执行函数时，函数局部变量的存储单元可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内值于处理器的指令集中，效率很高但是分配的内存容量有限-普通的局部变量。
- 从堆上分配，也称为动态内存分配。程序在运行的时候采用`malloc`或`new`申请任意多少内存，程序员自己负责在任何时候`free`或`delete`释放内存。动态内存的生存期由我们决定，使用非常灵活但是问题最多

### 10. 引用和指针有什么区别？

- 引用必须被初始化，指针不必
- 引用初始化后不能被改变，指针可以改变所指的对象
- 不存在指向空值的引用，但是存在指向空值的指针

### 11. C++是不是类型安全的？

不是， 类型的指针可以强制转换类型，类型之间也是可以强制转换

### 12. volatile作用

volatile关键词的第一个特性：易变性。所谓的易变性，在汇编层面反应出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。

volatile关键词的第二个特性：不可优化特性，volatile告诉编译器不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令一定会被执行。

volatile关键词第三个特性：顺序性。能够保证volatile变量间的顺序行，编译器不会进行乱序优化。

但是当volatile变量于非volatile变量之间进行操作时，是有可能被编译器交换顺序的。只是volatile变量之间进行操作不会被编译器交换顺序。哪怕你把所有的变量都声明成volatile变量，哪怕你杜绝编译器的乱序优化，这也只能够保证生成的汇编代码不是乱序的，CPU仍然可能进行乱序执行指令，导致程序依赖的逻辑出错，volatile对此是无能为力的。这个时候要想保证内存交换的顺序就要使用到内存屏障技术了，具体的实现可以参考： [C++内存模型和原子类型操作](https://wangyazhou.blog.csdn.net/article/details/119719946?spm=1001.2014.3001.5502)

### 13. static关键字的作用





== 现在飞书文档上更新后期在更新过来



















