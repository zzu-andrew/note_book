
:toc:

// 保证所有的目录层级都可以正常显示图片
:path: MQ/
:imagesdir: ../image/

// 只有book调用的时候才会走到这里
ifdef::rootpath[]
:imagesdir: {rootpath}{path}{imagesdir}
endif::rootpath[]


== kafka

Message Queue (MQ)，消息队列中间件，与其说是用来做异步解耦的不如说是一种对tcp、UDP、RPC、http等协议再次封装的上层协议，或者说是一种高级socket。

主要作用：

- 异步解耦
- 削峰填谷

=== 削峰填谷

假设有两个程序A和B，B服务每秒只能处理 100 个消息，但 A 服务却每秒发出 200 个消息，B 服务哪里顶得住，分分钟被压垮。如何解决这个问题-添加一层消息中间件来进行削峰填谷。 这次我们要加的中间层是 消息队列 Kafka。

.kafka消息队列
image::mq/image-2024-09-23-14-21-36-356.png[kafka]

=== 什么是消息队列

如果A直接向B发送，如果B服务每秒能处理的消息个数大于A服务每秒发送的个数，那么会导致B服务部分时候处于空闲状态(工作不饱和)。 +
如果B服务每秒处理的消息个数小于A服务发送的个数，那么B服务就会过载，处理不完的消息只能被B服务丢掉，为了解决这个问题，我们很容易想到给B增加个队列用来缓存消息。

.直连
image::mq/image-2024-09-23-15-04-13-782.png[add queue]

队列一般内部使用链表实现，来不及处理的消息就会在链表中积压，积压就会占用内存，当内存不足时压爆B服务，而且原先发送的所有消息都会随着B服务崩溃重启而丢失。为了解决这个问题，我们可以将队列单独拉出来作为一个独立的进程。

.简单的消息队列
image::mq/image-2024-09-23-15-12-21-251.png[]

这个简陋的单链表实现的消息缓存进程，就是所谓的消息队列。将发送数据的称为生产者，消费数据的称为消费者。 但是这个消息队列过于简陋，根本不存在所谓的高可靠、高性能、高可用、高扩展性，为了实现以上功能，我们需要对这个消息队列进行一下改进。

=== 高性能

B服务性能差导致消息队列中的消息不断积压，为了快速消费消息可以增加消费者，这样消费速度就蹭一下上来了，消费能力高的时候，为了不浪费带宽可以适当增加更多的生产者，提升消息队列的吞吐量。

.增加生产者和消费者
image::mq/image-2024-09-23-16-38-46-657.png[]

随着生产者和消费者都变多，我们会发现它们会同时争抢同一个消息队列，抢不到的一方就得等待，这不纯纯浪费时间吗！有解决方案吗？有！首先是对消息进行分类，每一类是一个 topic，然后根据 topic 新增队列的数量，生产者将数据按 topic 投递到不同的队列中，消费者则根据需要订阅不同的 topic。这就大大降低了 topic 队列的压力。

.多个topic
image::mq/image-2024-09-23-17-06-00-950.png[topics]

但单个 topic 的消息还是可能过多，我们可以将单个队列，拆成好几段，每段就是一个 partition分区，每个消费者负责一个 partition。这就大大降低了争抢，提升了消息队列的性能。

.多分区
image::mq/image-2024-09-23-17-24-09-993.png[]

=== 高扩展性

随着topic数量和partition的增加，单个机器可能会因为内存以及CPU资源有限成为限制，从而影响消息队列的整体性能。

.one broker
image::mq/image-2024-09-24-15-28-57-454.png[]

因此，我们可以考虑将分区放到不同机器上，将同一个主题不同的分区(Partition)分布到不同的机器上，我们将这种部署了分区的机器称为broker，通过部署多态机器，我们能极大的缓解因为CPU、内存等资源导致的消息队列性能下降等问题。

.more brokers
image::mq/image-2024-09-24-15-34-08-363.png[]



























https://mp.weixin.qq.com/s/SNMmCMV-gqkHtWS0Ca3j4g[小白debug什么是kafka]




=== `kafka`集群的架构

1. `broker`
2. topic
3. partition：分区，把同一个`topic`分成不同的分区，提高负载
   - leader 分区的主节点
   - follower 分区的从节点(小弟)
4. Consumer Group

=== 生产者往`kafka`发送数据流的流程(6步)

![image-20210313222030658](image/image-20210313222030658.png)

=== `kafka`选择分区模式(3种)

1. 指定往哪个分区写
2. 指定`Key`，`kafka`根据`key`做`hash`然后决定写哪个分区
3. 轮询方式

=== 生产者往`kafka`发送数据的模式(3)种

1. 0把数据发送给`Leader`就成功，效率最高，安全性最低
2. 1把数据发送给`Leader`，等待`leader`回`ACK`
3. `all`把数据发送给`leader`确保`follower`拉取数据回复`ack`给`Leader`，`Leader`再回复`ACK`；安全性最高




=== `kafka`的启动和创建`topic`



[kafka启动和创建topic](https://www.cnblogs.com/cq-yangzhou/p/11425047.html)



[kafka](https://www.cnblogs.com/qingyunzong/p/9004509.html)