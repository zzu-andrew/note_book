
:toc:

:icons: font

// 保证所有的目录层级都可以正常显示图片
:path: C++知识点总结/
:imagesdir: ../image/

// 只有book调用的时候才会走到这里
ifdef::rootpath[]
:imagesdir: {rootpath}{path}{imagesdir}
endif::rootpath[]


== Linux二进制分析

.汇编
****
如果你能够读得懂汇编源，那么所有的程序对你来说，都是开源的
****

== Linux环境和相关工具

[NOTE]
====
Linux自带了很多好用的二进制分析工具，这些可以在binutils中获取，具体的网址：
http://www.gnu.org/software/binutils[binutils]，里面包含了一些用于分析和破解的工具
====

=== Linux工具

==== *GDB* 后端程序员必备

我在飞书上有对应的文章讲解
https://ny5odfilnr.feishu.cn/docs/doccn3oRPLnUMmKnfc1qu4WKZIe[GDB]，同时也在b站上更新了视频讲解
https://www.bilibili.com/video/BV1Df4y1c7gG?spm_id_from=333.999.0.0&vd_source=d0f1fc53c13a7dcbda92faa2e368b71e[GDB讲解]

==== objdump

对代码和二进制文件可以进行快速的反汇编，但是要针对有挑战性或者针对恶意软件时，objdump就显现出局限性了。其最主要的缺陷就是需要依赖ELF头，并且不会进行控制流分析


- 查看ELF文件中所有节的数据或代码

`objdump -D
[red]#object#`

- 只查看ELF文件中的程序代码

`objdump -d
[red]#object#`

- 查看ELF文件所有符号

`objdump -tT
[red]#object#`

==== objcopy

`objcopy` 很小但也很强大，可以用他来分析和修改任意类型的ELF文件，可以单独修改ELF文件的一小段，比如将A文件的 `.data` 段复制到B文件中

`objcopy –only-section=.data <infile> <outfile>`


==== *strace*

系统调用追踪，基于ptrace,strace 通过在一个循环中使用PTRACE_SYSCALL 请求来显示运行中程序的系统调用（也称为 syscalls）活动相关的信息以及程序执行中捕捉到 的信号量。 strace 在调试过程中非常有用，也可以用来收集运行时系统调用相关的信息

- 使用strace来追踪一个基本的程序

`strace ./main -o ls.out`

- 附加到一个运行的进程上

`strace -p <pid> -o deamon.out`

- 如果想看读入到文件描述符3中的所有数据，可以运行下面的命令

`strace –e read=3 /bin/ls`

同样使用 `-e write=3` 可以查看写入到对应文件描述符中国的数据

==== ltrace

库追踪，追踪库中用到的库函数

[source, bash]
----
- Print (trace) library calls of a program binary:
   ltrace ./{{program}}

 - Count library calls. Print a handy summary at the bottom:
   ltrace -c {{path/to/program}}

 - Trace calls to malloc and free, omit those done by libc:
   ltrace -e malloc+free-@libc.so* {{path/to/program}}

 - Write to file instead of terminal:
   ltrace -o {{file}} {{path/to/program}}
----

==== ftrace

函数追踪

[red]#https://github.com/elfmaster/ftrace[github ftrace]#

==== readelf

readelf命令是一个非常有用的解析工具，在进行正式的反汇编之前需要收集目标文件的相关信息，该工具能够提供收集信息所需要特定的ELF的所有数据。主要有以下几种：

a. 符号
b. 段
c. 节
d. 重定向入口
e. 数据动态链接

*常用语句*

- 查询节表头

`readelf -S <object>`

- 查询程序表头

`readelf -l <object>`

- 查询ELF文件头数据

`readelf -e <object>`

- 查询符号表

`readelf -s <object>`

- 查询重定位入口

`readelf -r <object>`

- 查询动态段

`readelf -d <object>`




=== 设备和文件

linux中有许多设备和文件，还有/proc入口，对于反汇编和工程师来说都非常有用

==== `/proc/<pid>/maps`

该maps中保存了一个进程镜像的布局，通过展现每个内存映射来实现，展现的内容包含可执行文件、共享库、栈、堆和VDSO等，在解析进程空间布局的时候非常有用


==== `/proc/kcore`
kcore是proc文件系统的一项，linux内核的动态核心文件。其实就是使用ELF核心文件形式来 展现出原生内核内存转储，可以使用gdb对  `/proc/kcore/` 来对内核进行调试和分析

==== `/bootstrap/System.map.*`

里面包含了内核的所有符号表

==== `/proc/kallsyms`

和System.map类似，区别就是kallsyms是内核所属的/proc的一个入口并且可以动态更新，如果安装了新的LKM(Linux Kernel Module)，符号会自动添加到 `/processor/kallsyms` 中，如果能在 `CONFIG_KALLSYMS_ALL` 内核配置中指明，这可以包含内核中的全部符号。

==== `/proc/iomem`

iomem与`/proc/<pid>/maps` 类似，不过是和系统内存相关的，如果想知道内核text段所映射的物理内存地址，可以通过搜索`Kernel` 字符串进行查找，要使用root查找，否则给出的地址都是空的

`grep "Kernel" /proc/iomem`

[source, bash]
----
andrew@andrew-G3-3590:/proc$ sudo grep "Kernel" /proc/iomem
  195c00000-196c02666 : Kernel code
  196e00000-197840fff : Kernel rodata
  197a00000-197d6e33f : Kernel data
  198068000-1985fffff : Kernel bss
----

==== `ECFS`

extended core file snapshot 扩展核心文件快照，是一项特殊的核心转存储技术，专门为进程镜像的高级取证分析所设计。
https://github.com/elfmaster/ecfs[ECFS]

=== 连接器相关环境指针

动态加载/连接器以及链接的概念，在程序链接执行的过程中都是避不开的基本组成部分。

==== `LD_PRELOAD` 环境变量

指定到一个库的路径，这里面的库比其他库有更高的优先级，这就允许预加载库中的函数和符号能够覆盖掉后续链接库中的函数和符号。 +
运用该技术，允许你通过重定向共享库函数来进行运行时修复，通常运用该技术绕过反调试代码。

==== `LD_SHOW_AUXV` 环境变量

该环境变量能够通知程序加载器来展示程序运行时的辅助向量，辅助向量是放在程序栈(通过内核的ELF常规加载方式)上的信息，附带了传递给动态连接器的程序相关的信息。
例如，要想获取进程镜像 VDSO 页的内存地址（也可以使用 maps 文件获取，之前介绍过），就需要查询 AT_SYSINFO。

[source, bash]
----
andrew@andrew-G3-3590:/proc$ LD_SHOW_AUXV=1 whoami
AT_SYSINFO_EHDR:      0x7ffdd6ae4000
AT_HWCAP:             bfebfbff
AT_PAGESZ:            4096
AT_CLKTCK:            100
AT_PHDR:              0x55afacc19040
AT_PHENT:             56
AT_PHNUM:             13
AT_BASE:              0x7f99995fc000
AT_FLAGS:             0x0
AT_ENTRY:             0x55afacc1b700
AT_UID:               1000
AT_EUID:              1000
AT_GID:               1000
AT_EGID:              1000
AT_SECURE:            0
AT_RANDOM:            0x7ffdd6a2e279
AT_HWCAP2:            0x2
AT_EXECFN:            /usr/bin/whoami
AT_PLATFORM:          x86_64
andrew
----


==== 连接器脚本

连接器脚本是一个值得重点关注，因为连接器脚本是由连接器解释的，把程序划分为相应的节、内存和符号。默认的连接器脚本可以使用 `ld -verbose` 进行查看

ld 链接器程序有其自己解释的一套语言，当有文件（如可重定位的目标
文件、共享库和头文件）输入时， ld 链接器程序会用自己的语言来决定输出
文件（如可执行程序）的组织方式。例如，如果输出的是一个 ELF 可执行文
件，链接器脚本能够决定该输出文件的布局，以及每个段里面包含哪些节。
另外举一个例子： .bss 节总是放在 data 段的末尾，这就是链接器脚本决定
的


== ELF二进制格式

ELF文件已经成为UNIX和类UNIX系统的标准二进制格式。 ELF文件可以用于可执行文件，共享库，目标文件，coredump文件以及内核引导镜像文件。

通过对ELF文件的学习你可以理解程序如何映射到磁盘兵加载到内存中的

[TIP]
.ELF文件知识点
====
- ELF文件类型
- 程序头
- 节头
- 符号
- 重定位
- 动态链接
- 编码ELF解析器
====

=== ELF文件类型

ELF通常有以下几种文件类型

- `ET_NONE` 未知类型，标明文件类型不确定或者还没有被定义
- `ET_REL` 从定位文件，ELF类型标记为relocatable意味着该文件被标记为一段可重定位的代码，有时也称之为目标文件，其实说白了就是编译代码之后留下的.o文件，这些文件中包含了创建可执行文件所需的代码和数据。
- `ET_EXEC` 可执行文件。ELF类型为executable，表明这个文件被标记为可执行文件，也就是可执行程序
- `ET_DYN` 共享目标文件，ELF类型为dynamic，也称之为动态共享库
- `ET_CORE` 核心文件，也成为核心转存储文件，是程序崩溃时的镜像信息

可以通过 `man 5 elf` 来查看ELF文件的详细信息

ELF文件头的结构体定义如下

[source, cpp]
----
#define EI_NIDENT 16
typedef struct {
   unsigned char e_ident[EI_NIDENT];
   uint16_t      e_type;
   uint16_t      e_machine;
   uint32_t      e_version;
   ElfN_Addr     e_entry;
   ElfN_Off      e_phoff;
   ElfN_Off      e_shoff;
   uint32_t      e_flags;
   uint16_t      e_ehsize;
   uint16_t      e_phentsize;
   uint16_t      e_phnum;
   uint16_t      e_shentsize;
   uint16_t      e_shnum;
   uint16_t      e_shstrndx;
} ElfN_Ehdr;
----

=== ELF程序头

ELF程序头是对二进制文件段的描述，是程序装载必必需的一部分。段(segment)是内核装载时被解析的，描述了磁盘上可执行文件的内存布局，以及如何映射到内存中。可以通过引用原始ELF头中名为e_phoff(程序头偏移量)的偏移量来得到程序比头表。

[[PHdr01]]
[source, cpp]
----
typedef struct {
   uint32_t   p_type;
   Elf32_Off  p_offset;
   Elf32_Addr p_vaddr;
   Elf32_Addr p_paddr;
   uint32_t   p_filesz;
   uint32_t   p_memsz;
   uint32_t   p_flags;
   uint32_t   p_align;
} Elf32_Phdr;

typedef struct {
   uint32_t   p_type;   // 段类型
   uint32_t   p_flags; // 段标记 I.E (execute|read|write)
   Elf64_Off  p_offset; // 段偏移
   Elf64_Addr p_vaddr; // 段虚拟地址
   Elf64_Addr p_paddr; // 段物理地址
   uint64_t   p_filesz; // 段在文件中的大小
   uint64_t   p_memsz;  // 段在内存中的大小
   uint64_t   p_align; // 段在内存中的对其方式
} Elf64_Phdr;
----

==== `PT_LOAD`

一个可执行程序最少有一个`PT_LOAD`类型的段，这类程序头秒数的是可装载的段，也就是说这种类型的段将被装载或者映射到内存中。 +
一个需要动态链接的ELF可执行文件，通常需要包含以下两个可装载的段(PT_LOAD):

- 存放程序代码的text段
- 存放全局变量和动态链接信息的dta段

上面两个段，会按照p_align的对其的方式在内存中对其。

[IMPORTANT]
====
通常将text段代码权限设置为 PF_X|PF_R(读和可执行) +
将data段的权限设置为 PF_W|PF_R(读和写)，有些病毒通过修改ELF文件的这些权限来实现病毒感染，如：千面人病毒(polymorphic virus)
====

==== `PT_DYNAMIC` 动态段的 `Phdr`

动态段是动态链接可执行文件特有的，包含了动态连接器所必须的一些信息，在动态段包含了一些标记和指针。

- 运行时需要链接的共享库列表
- 全局偏移表(GOT)的地址
- 从定位条目的相关信息

man手册中有这样一段内容，说明了d_tag的作用

.d_tag
****
The .dynamic section contains a series of structures that hold relevant dynamic linking  informa‐
tion.  The d_tag member controls the interpretation of d_un.
[source, cpp]
typedef struct {
   Elf32_Sword    d_tag;
   union {
       Elf32_Word d_val;
       Elf32_Addr d_ptr;
   } d_un;
} Elf32_Dyn;
extern Elf32_Dyn _DYNAMIC[];

[source, cpp]
typedef struct {
   Elf64_Sxword    d_tag;
   union {
       Elf64_Xword d_val;
       Elf64_Addr  d_ptr;
   } d_un;
} Elf64_Dyn;
extern Elf64_Dyn _DYNAMIC[];
****

动态段包含了一些结构体，如上，这些结构体中存放着动态链接相关的信息，d_tag成员变量控制着d_un的含义。

[cols="1,3"]
.标记名List
|===
|标记名 |描述

|DT_HASH
|符号散列表地址

|DT_STRTAB
|字符串表的地址

|DT_SYMTAB
|符号表地址

|DT_RELA
|相对地址重定位表的地址

|DT_RELASZ
|Rela 表的字节大小

|DT_RELAENT
|Rela 表条目的字节大小

|DT_STRSZ
|字符串表的字节大小

|DT_SYMENT
|符号表条目的字节大小

|DT_INIT
|初始化函数的地址

|DT_FINI
|终止函数的地址

|DT_SONAME
|共享目标文件名的字符串表偏移量

|DT_RPATH
|库搜索路径的字符串表偏移量

|DT_SYMBOLIC
|修改链接器，在可执行文件之前的共享目标文件中搜索符号

|DT_REL
|Rel relocs 表的地址

|DT_RELSZ
|Rel 表的字节大小

|DT_RELENT
|Rel 表条目的字节大小

|DT_PLTREL
|PLT 引用的 reloc 类型（ Rela 或 Rel）

|DT_DEBUG
|还未进行定义，为调试保留

|DT_TEXTREL
|缺少此项表明重定位只能应用于可写段

|DT_JMPREL
|仅用于 PLT 的重定位条目地址

|DT_BIND_NOW
|指示动态链接器在将控制权交给可执行文件之前处理所有的重定位

|DT_RUNPATH
|库搜索路径的字符串表偏移量

|===


==== PT_NONE

该段可以用来保存与特定供应商或者系统相关的附加信息，一些供应商或者系统构建者有时需要在目标文件中标记上特定的信息，以便于对程序的一致性、兼容性进行检查。比较有意思的是，因为可执行文件运行时并不需要这一段，这个段成为了很容易受感染的段。

具体的可参见：
http://vxheavens.com/lib/vhe06.html[VHE]

==== PT_INTERP
PT_INTERP段只将位置和大小信息存放在一个以null结尾的字符串中，是对程序解释器位置的描述。例如 /libc/linux-ld.so.2一般是指动态连接器的位置，也即程序解释器的位置

==== PT_PHDR
PT_PHDR段保存了程序头表本身的位置和大小。phdr表保存了所有Phdr对文件中段的描述信息

可以使用 `readelf –l <filename>` 命令来查看文件的Phdr表：

[[JT01]]
[source, bash]
.readelf -f <filename>
----
andrew@andrew-G3-3590:/work/note_book/cmake-build-debug/src$ readelf -l ./main

Elf 文件类型为 DYN (共享目标文件)
Entry point 0x1100
There are 13 program headers, starting at offset 64

程序头：
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000002d8 0x00000000000002d8  R      0x8
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000ab8 0x0000000000000ab8  R      0x1000
  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                 0x00000000000003f5 0x00000000000003f5  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                 0x0000000000000250 0x0000000000000250  R      0x1000
  LOAD           0x0000000000002d60 0x0000000000003d60 0x0000000000003d60
                 0x00000000000002b0 0x00000000000003f8  RW     0x1000
  DYNAMIC        0x0000000000002d80 0x0000000000003d80 0x0000000000003d80
                 0x0000000000000200 0x0000000000000200  RW     0x8
  NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
                 0x0000000000000020 0x0000000000000020  R      0x8
  NOTE           0x0000000000000358 0x0000000000000358 0x0000000000000358
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
                 0x0000000000000020 0x0000000000000020  R      0x8
  GNU_EH_FRAME   0x0000000000002014 0x0000000000002014 0x0000000000002014
                 0x0000000000000074 0x0000000000000074  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000002d60 0x0000000000003d60 0x0000000000003d60
                 0x00000000000002a0 0x00000000000002a0  R      0x1

 Section to Segment mapping:
  段节...
   00
   01     .interp
   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt
   03     .init .plt .plt.got .plt.sec .text .fini
   04     .rodata .eh_frame_hdr .eh_frame
   05     .init_array .fini_array .dynamic .got .data .bss
   06     .dynamic
   07     .note.gnu.property
   08     .note.gnu.build-id .note.ABI-tag
   09     .note.gnu.property
   10     .eh_frame_hdr
   11
   12     .init_array .fini_array .dynamic .got
----

从上到下一次是，PT_PHDR,PT_INTERP,PT_LOAD段 +
text段是可读可执行，data段是可读可写，这两个段都是按照0x1000(4096)的对其标识符，放好对应一页

=== ELF节头

[IMPORTANT]
.segment and section
====
在开始之前段(segment)和节不能搞混了，经常有人把段和节搞混了，节不是段。段是程序执行的必要组成部分，在每个段中会有代码或者数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于调试。
====

节头对于程序来说不是必需的，没有节头表程序仍然可以正常执行，因为节头表没有对程序的内存布局进行描述，对程序内存布局的描述是程序头表的任务。节头只是对程序头的补充。使用命令 `readelf -l` 可以查看一个可执行程序的节头，可以很直观的看到节和段之间的关系

<<JT01,节头>>

如果一个程序没有节头，并不是意味着可执行文件中没有节了，知识节头的信息没有，无法通过节头来引用节而已。对于调试器或者反汇编的程序来说只是可以参考的信息变少了。

.总结
每一个节都保存了某种类型的代码或者数据，数据可以是程序中的全局变量，也可以是连接器所需的动态链接信息。每个可执行程序都有节但是不一定有节头，尤其是有人故意将节头从表中删除(去除节头增加调试难度)，当然程序默认是有节头的。
常见的调试工具gdb，objcopy, objdump等都需要使用节头来定位到符号数据的节来获取符号信息。如果没有节头，那么gdb和objdump这些工具几乎无用武之地

上面我们展示了Phdr<<PHdr01,程序头>>，这里我们看一下节头的数据结构：

[source, cpp]
.section struct
----
typedef struct {
   uint32_t   sh_name;
   uint32_t   sh_type;
   uint32_t   sh_flags;
   Elf32_Addr sh_addr;
   Elf32_Off  sh_offset;
   uint32_t   sh_size;
   uint32_t   sh_link;
   uint32_t   sh_info;
   uint32_t   sh_addralign;
   uint32_t   sh_entsize;
} Elf32_Shdr;

typedef struct {
   uint32_t   sh_name;  // offet into shdr string table for shdr name
   uint32_t   sh_type; // 类型 I.E SHT_PROGBITS
   uint64_t   sh_flags; // shdr flags I.E SHT_ERITE|SHT_ALLOC
   Elf64_Addr sh_addr;  // 指向节开始的地址
   Elf64_Off  sh_offset; // shdr在文件开头的偏移的大小
   uint64_t   sh_size; // 当前节占用的大小
   uint32_t   sh_link; // 指向其他节
   uint32_t   sh_info; // 具体含义 依赖类型的设置
   uint64_t   sh_addralign; // 当前节对其方式 按照那种方式对其
   uint64_t   sh_entsize; // size of each certain entries that may be in section
} Elf64_Shdr;
----

==== `.text` 节

..text
****
[yellow]#.text# 节是保存了程序代码指令的代码节。一段可执行程序，如果存在 Phdr，.text就会存在于text段中。由于.text保存了程序代码，因此此节类型为SHT_PROGBITS
****

==== `.rodata` 节

..rodata
****
只读数据如 `printf("hello world")` 中的字符串就会被存放到只读节.rodata中。因为是只读的，所以只能在text段找到.rodata而data段中不存在.rodata节。因为是只读的所以.rodata节的类型为SHT_PROGBITS
****

==== `.plt` 节

..plt
****
.plt节中包含了动态连接器调用从共享库导入的函数所必须的相关代码，由于其存在于text段，同样也是保存了代码，因此类型为SHT_PROGBITS
****

==== `.data` 节

..data
****
这里千万不要弄混了，.data节和data段是两个东西，.data节存在于data段中，保存了初始化的全局变量等数据。由于其保存了程序的变量数据，因此此类型为SHT_PROGBITS
****

==== `.bss` 节



==== `.got.plt` 节


==== `.dynsym` 节


==== `.synstr` 节


==== `.rel.*` 节


==== `.hash` 节


==== `.symtab` 节



==== `.strtab` 节

==== `.shstrtab` 节


==== `.ctors` 和 `.dtors` 节




















== Linux进程追踪





== ELF病毒技术-(LinuxSll/Unix技术)



== Linux二进制保护




== Linux下二进制取证分析


== 进程内存取证分析



== ECFS-扩展核心文件快照技术




== Linux二进制/proxy/kcore分析









