
:toc:

:icons: font


:path: Linux/
:imagesdir: ../image/

// 只有book调用的时候才会走到这里
ifdef::rootpath[]
:imagesdir: {rootpath}{path}{imagesdir}
endif::rootpath[]

== 系统知识

=== PC系统架构

[[PCSystem]]
image::image-2022-07-02-10-29-44-536.png[PC系统架构]

=== 一个程序的执行过程

[plantuml, diagram=helloworld-exec,format=png]
....
编译器 : ccl
汇编器 : as
链接器 : ld

[*] -> 预处理起 : hello.c
预处理起 -> 编译器 : hello.i
编译器 -> 汇编器 : hello.s
汇编器 -> 链接器 :  hello.o
链接器 -> [*] : hello
....

[IMPORTANT]
处理器的核心就是PC寄存器，用来存储计算机下一步需要执行的指令

<<PCSystem, 程序执行过程>>
假如有一个可执行程序hello, 正常程序是存储在磁盘的中的，当需要执行时，系统会将程序加载到内存中(主内存中)，当处理器开始执行程序hello时，会将指令通过寄存器送往运算单元，并将需要打印的字符等通过寄存器复制到现实设备





=== CPU缓存

无论什么样的代码最终都会交给CPU来执行，不要觉得CPU缓存这些知识没有用，正是这些知识能让你写出比别人快的代码拉开与别的程序员之间的差距。

首先，我们都知道现在的CPU多核技术，都会有几级缓存，老的CPU会有两级内存（L1和L2），新的CPU会有三级内存（L1，L2，L3 ），如下图所示：

image::image-2023-06-05-10-59-06-497.png[cpu-cache]

https://ny5odfilnr.feishu.cn/docs/doccn5LErBvC5qtwGZRyhb9SJgc[参考 CPU-cache]

其中：

- L1缓存分成两种，一种是指令缓存，一种是数据缓存。L2缓存和L3缓存不分指令和数据。
- L1和L2缓存在每一个CPU核中，L3则是所有CPU核心共享的内存。
- L1、L2、L3的越离CPU近就越小，速度也越快，越离CPU远，速度也越慢。

再往后面就是内存，内存的后面就是硬盘。我们来看一些他们的速度：

- L1 的存取速度：4 个CPU时钟周期
- L2 的存取速度： 11 个CPU时钟周期
- L3 的存取速度：39 个CPU时钟周期
- RAM内存的存取速度：107 个CPU时钟周期

我们可以看到，L1的速度是RAM的27倍，但是L1/L2的大小基本上也就是KB级别的，L3会是MB级别的。例如：Intel(R) Xeon(R) CPU E5-2650 v4 @ 2.20GHz ，
是一个6核的CPU，每核上的L1是64KB（数据和指令各32KB），L2 是 256K，L3有30MB。

_我们可以通过lscpu来查看cpu的缓存信息_
[source, bash]
.cpu cache
----
$lscpu
···
L1d 缓存：          32K
L1i 缓存：          32K
L2 缓存：           256K
L3 缓存：           30720K
NUMA 节点0 CPU：    0-3
···
----

我们的数据就从内存向上，先到L3，再到L2，再到L1，最后到寄存器进行CPU计算。为什么会设计成三层？这里有下面几个方面的考虑：

一个方面是物理速度，如果要更大的容量就需要更多的晶体管，除了芯片的体积会变大，更重要的是大量的晶体管会导致速度下降，
因为访问速度和要访问的晶体管所在的位置成反比，也就是当信号路径变长时，通信速度会变慢。这部分是物理问题。
另外一个问题是，多核技术中，数据的状态需要在多个CPU中进行同步，并且，我们可以看到，cache和RAM的速度差距太大，所以，多级不同尺寸的缓存有利于提高整体的性能。
这个世界永远是平衡的，一面变得有多光鲜，另一面也会变得有多黑暗。建立这么多级的缓存，一定就会引入其它的问题，这里有两个比较重要的问题，

一个是比较简单的缓存的命中率的问题。
另一个是比较复杂的缓存更新的一致性问题。
尤其是第二个问题，在多核技术下，这就很像分布式的系统了，要对多个地方进行更新。

==== 缓存的命中

在说明这两个问题之前。我们需要要解一个术语 Cache Line。 +
缓存基本上来说就是把后面的数据加载到离自己近的地方，对于CPU来说，它是不会一个字节一个字节的加载的。
因为这非常没有效率，一般来说都是要一块一块的加载的，对于这样的一块一块的数据单位，术语叫“Cache Line”。
一般来说，一个主流的CPU的Cache Line 是 64 Bytes（也有的CPU用32Bytes和128Bytes），
64Bytes也就是16个32位的整型，这就是CPU从内存中捞数据上来的最小数据单位。

比如：Cache Line是最小单位（64Bytes），所以先把Cache分布多个Cache Line，比如：L1有32KB，那么，32KB/64B = 512 个 Cache Line。

一方面，缓存需要把内存里的数据放到放进来，英文叫 CPU Associativity。Cache的数据放置的策略决定了内存中的数据块会拷贝到CPU Cache中的哪个位置上，
因为Cache的大小远远小于内存，所以，需要有一种地址关联的算法，能够让内存中的数据可以被映射到Cache中来。
这个有点像内存地址从逻辑地址向物理地址映射的方法，但不完全一样。

基本上来说，我们会有如下的一些方法。

- 一种方法是，任何一个内存地址的数据可以被缓存在任何一个Cache Line里，这种方法是最灵活的，但是，如果我们要知道一个内存是否存在于Cache中，
我们就需要进行O(n)复杂度的Cache遍历，这是很没有效率的。
- 另一种方法，为了降低缓存搜索算法，我们需要使用像Hash Table这样的数据结构，最简单的hash table就是做“求模运算”，比如：我们的L1 Cache有512个Cache Line，那么，公式：（内存地址 mod 512）* 64 就可以直接找到所在的Cache地址的偏移了。但是，这样的方式需要我们的程序对内存地址的访问要非常地平均，不然冲突就会非常严重。这成了一种非常理想的情况了。
- 为了避免上述的两种方案的问题，于是就要容忍一定的hash冲突，也就出现了 N-Way 关联。也就是把连续的N个Cache Line绑成一组，然后，先把找到相关的组，然后再在这个组内找到相关的Cache Line。这叫 Set Associativity。如下图所示。

image::image-2023-06-05-17-11-53-833.png[]

对于 N-Way 组关联，可能有点不好理解，这里个例子，并多说一些细节（不然后面的代码你会不能理解），Intel 大多数处理器的L1 Cache都是32KB，8-Way 组相联，Cache Line 是64 Bytes。这意味着，

- 32KB的可以分成，32KB / 64 = 512 条 Cache Line。
- 因为有8 Way，于是会每一Way 有 512 / 8 = 64 条 Cache Line。
- 于是每一路就有 64 x 64 = 4096 Byts 的内存。

为了方便索引内存地址:

- Tag：每条 Cache Line 前都会有一个独立分配的 24 bits来存的 tag，其就是内存地址的前24bits
- Index：内存地址后续的6个bits则是在这一Way的是Cache Line 索引，2^6 = 64 刚好可以索引64条Cache Line
- Offset：再往后的6bits用于表示在Cache Line 里的偏移量

如下图所示：（图片来自《Cache: a place for concealment and safekeeping》）

当拿到一个内存地址的时候，先拿出中间的 6bits 来，找到是哪组。

image::image-2023-06-05-17-20-07-957.png[]

.缓存命中
然后，在这一个8组的cache line中，再进行O(n) n=8 的遍历，主是要匹配前24bits的tag。如果匹配中了，就算命中，如果没有匹配到，那就是cache miss，如果是读操作，就需要进向后面的缓存进行访问了。L2/L3同样是这样的算法。而淘汰算法有两种，一种是随机一种是LRU。现在一般都是以LRU的算法（通过增加一个访问计数器来实现）

image::image-2023-06-05-17-33-50-430.png[]

这也意味着：

- L1 Cache 可映射 36bits 的内存地址，一共 2^36 = 64GB的内存
- 当CPU要访问一个内存的时候，通过这个内存中间的6bits 定位是哪个set，通过前 24bits 定位相应的Cache Line。
- 就像一个hash Table的数据结构一样，先是O(1)的索引，然后进入冲突搜索。
- 因为中间的 6bits 决定了一个同一个set，所以，对于一段连续的内存来说，每隔4096的内存会被放在同一个组内，导致缓存冲突。

此外，当有数据没有命中缓存的时候，CPU就会以最小为Cache Line的单元向内存更新数据。当然，CPU并不一定只是更新64Bytes，因为访问主存实在是太慢了，所以，一般都会多更新一些。好的CPU会有一些预测的技术，如果找到一种pattern的话，就会预先加载更多的内存，包括指令也可以预加载。这叫 Prefetching 技术 （参看，Wikipedia 的 Cache Prefetching 和 纽约州立大学的 Memory Prefetching）。比如，你在for-loop访问一个连续的数组，你的步长是一个固定的数，内存就可以做到prefetching。

了解这些细节，会有利于我们知道在什么情况下有可以导致缓存的失效。

==== 缓存的一致性
对于主流的CPU来说，缓存的写操作基本上是两种策略（参看本站《缓存更新的套路》），

一种是Write Back，写操作只要在cache上，然后再flush到内存上。
一种是Write Through，写操作同时写到cache和内存上。
为了提高写的性能，一般来说，主流的CPU（如：Intel Core i7/i9）采用的是Write Back的策略，因为直接写内存实在是太慢了。

好了，现在问题来了，如果有一个数据 x 在 CPU 第0核的缓存上被更新了，那么其它CPU核上对于这个数据 x 的值也要被更新，这就是缓存一致性的问题。（当然，对于我们上层的程序我们不用关心CPU多个核的缓存是怎么同步的，这对上层的代码来说都是透明的）

一般来说，在CPU硬件上，会有两种方法来解决这个问题。

Directory 协议。这种方法的典型实现是要设计一个集中式控制器，它是主存储器控制器的一部分。其中有一个目录存储在主存储器中，其中包含有关各种本地缓存内容的全局状态信息。当单个CPU Cache 发出读写请求时，这个集中式控制器会检查并发出必要的命令，以在主存和CPU Cache之间或在CPU Cache自身之间进行数据同步和传输。
Snoopy 协议。这种协议更像是一种数据通知的总线型的技术。CPU Cache通过这个协议可以识别其它Cache上的数据状态。如果有数据共享的话，可以通过广播机制将共享数据的状态通知给其它CPU Cache。这个协议要求每个CPU Cache 都可以“窥探”数据事件的通知并做出相应的反应。如下图所示，有一个Snoopy Bus的总线。


因为Directory协议是一个中心式的，会有性能瓶颈，而且会增加整体设计的复杂度。而Snoopy协议更像是微服务+消息通讯，所以，现在基本都是使用Snoopy的总线的设计。

这里，我想多写一些细节，因为这种微观的东西，让人不自然地就会跟分布式系统关联起来，在分布式系统中我们一般用Paxos/Raft这样的分布式一致性的算法。而在CPU的微观世界里，则不必使用这样的算法，原因是因为CPU的多个核的硬件不必考虑网络会断会延迟的问题。所以，CPU的多核心缓存间的同步的核心就是要管理好数据的状态就好了。
这里介绍几个状态协议，先从最简单的开始，MESI协议，这个协议跟那个著名的足球运动员梅西没什么关系，其主要表示缓存数据有四个状态：Modified（已修改）, Exclusive（独占的）,Shared（共享的），Invalid（无效的）。

这些状态的状态机如下所示（有点复杂，你可以先不看，这个图就是想告诉你状态控制有多复杂）：



下面是个示例（如果你想看一下动画演示的话，这里有一个网页（MESI Interactive Animations），你可以进行交互操作，这个动画演示中使用的Write Through算法）：


当前操作	CPU0	CPU1	Memory	说明
1) CPU0 read(x)	 x=1 (E)		x=1	只有一个CPU有 x 变量，
所以，状态是 Exclusive
2) CPU1 read(x)	 x=1 (S)	x=1(S)	x=1	有两个CPU都读取 x 变量，
所以状态变成 Shared
3) CPU0 write(x,9)	 x=9 (M)	x=1(I)	x=1	变量改变，在CPU0中状态
变成 Modified，在CPU1中
状态变成 Invalid
4) 变量 x 写回内存	 x=9 (M)	X=1(I)	x=9	目前的状态不变
5) CPU1  read(x)	 x=9 (S)	x=9(S)	x=9	变量同步到所有的Cache中，
状态回到Shared


MESI 这种协议在数据更新后，会标记其它共享的CPU缓存的数据拷贝为Invalid状态，然后当其它CPU再次read的时候，就会出现 cache miss 的问题，此时再从内存中更新数据。从内存中更新数据意味着20倍速度的降低。我们能不能直接从我隔壁的CPU缓存中更新？是的，这就可以增加很多速度了，但是状态控制也就变麻烦了。还需要多来一个状态：Owner(宿主)，用于标记，我是更新数据的源。于是，出现了 MOESI 协议

MOESI协议的状态机和演示示例我就不贴了（有兴趣可以上Berkeley上看看相关的课件），我们只需要理解MOESI协议允许 CPU Cache 间同步数据，于是也降低了对内存的操作，性能是非常大的提升，但是控制逻辑也非常复杂。

顺便说一下，与 MOESI 协议类似的一个协议是 MESIF，其中的 F 是 Forward，同样是把更新过的数据转发给别的 CPU Cache 但是，MOESI 中的 Owner 状态 和MESIF 中的 Forward 状态有一个非常大的不一样—— Owner状态下的数据是dirty的，还没有写回内存，Forward状态下的数据是clean的，可以丢弃而不用另行通知。

需要说明的是，AMD用MOESI，Intel用MESIF。所以，F 状态主要是针对 CPU L3 Cache 设计的（前面我们说过，L3是所有CPU核心共享的）。（相关的比较可以参看StackOverlow上这个问题的答案）





== ARM


=== ARM寄存器以及工作模式

image::image-2022-07-02-10-56-42-650.png[ARM处理器以及工作模式]

ARM在实际工作中，各个模式之间会相互切换，其中比较特殊的事FIQ，因为FIQ拥有的寄存器比较多，又因为FIQ的响应优先级比较高，因此FIQ能能更快的切换状态。

1. R0-R12是通用寄存器，放通用数据
2. 各个模式R0-R12与User模式是共享的除了FIQ(F8-F12自有)，PC CPSR共享
3. User模式没有SPSR














==== 什么是大小端

小端(Little-endian)：就是低字节排放在内存的的低地址端，高位字节排放到内存的高地址端 +
大端(Big-endian)：就是高位字节排放在内存的低地址端，低字节排放到内存的高地址端

[TIP]
1)大端模式：
低地址 -----------------> 高地址
0x12  |  0x34  |  0x56  |  0x78
2)小端模式：
低地址 ------------------> 高地址
0x78  |  0x56  |  0x34  |  0x12

判断系统大小端

.BgiEndian.cpp
[source, cpp]
----
bool BigEndian()
{
    union
    {
        uint16_t a;
        char b;
    }num;
    num.a = 0x1234;
    if(num.b == 0x12)
    {
        return true;
    }
    return false;
}
----






=== 文件IO









=== 进程间通信







=== 线程间同步







=== 守护进程



=== 内存

共享内存系统中使用一个或者多个多核处理器，这些核之间每个核有自己的L1Cache，其他的Cache可以在核之间进行共享，也可以不进行共享。

image::image-2022-10-17-09-28-59-095.png[]


在拥有多个多核处理器的共享内存系统中，互联网络可以将所有的处理器直接连接到主存上，或者将每个处理器直接连接到一块内存，通过处理器内置的特殊的硬件使得各个处理器可以访问内存中的其他块。

当所有核都链接到一块内存上时，访问内存中任何一个区域的时间都相同，因此又被称为一致内存访问系统UMA(Uniform Memory Access)。

.UMA系统
image::image-2022-10-17-09-33-51-443.png[]

核访问与自己直接相连的内存区域，比访问其它区域快的多，因为访问其它区域需要通过另外一个芯片，因此被称为非一致性内存访问系统NUMA(Nonuniform Memory Access).

.NUMA系统
image::../image/image-2022-10-17-09-37-08-350.png[]


=== 内存管理

Linux内存管理，内存寻址，虚拟内存，内存调页算法，任务调度算法

[TIP]
Linux虚拟内存实现需要6种机制支持：地址映射机制、内存分配回收机制、缓存和刷新机制、请求页机制、交换机机制、内存共享机制

内存管理程序通过映射机制(MMU)可以把用户程序的逻辑地址映射到物理地址。当用户程序运行时，如果发现程序中的虚拟地址没有对应的物理地址，就发出请求页的请求，如果有空闲的内存可供分配，就请求分配内存(此处需要内存的分配和回收机制)，并把使用的物理页记录到缓存中(使用了缓存机制)。如果没有足够的内存可供分配，那么就调用交换机制，腾出一部分内存。另外在地址映射中要通过TLB(翻译后缓存储器)来寻找物理页；交换机知中也要用到交换缓存，并且把物理页内容交换到文件中，也要修改页表来映射文件地址。





=== 信号
常见的信号？ 操作系统如何将一个信号通知到进程

[source, bash]
----
andrew@andrew-G3-3590:~$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX
----
信号是进程之间传递消息的一种方法，信号全称为软中断信号，当然有诶有些人称作软中断 +
进程间可以通过调用系统调用kill发送信号，
[red]#几种常见的信号#：

[source, bash]
----
SIGHUP 1 A 终端挂起或者控制进程终止
SIGINT 2 A 键盘中断（如break键被按下）
SIGQUIT 3 C 键盘的退出键被按下
SIGILL 4 C 非法指令
SIGABRT 6 C 由abort(3)发出的退出指令
SIGFPE 8 C 浮点异常
SIGKILL 9 AEF Kill信号
SIGSEGV 11 C 无效的内存引用
SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道
----


=== 在线编译工具

https://www.godbolt.org[在线编译工具]





=== qemu 内核调试

www.kernel.org内核地址


https://www.bilibili.com/read/cv11271232 教程











