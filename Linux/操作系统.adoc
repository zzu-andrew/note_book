
:toc:

:icons: font


:path: Linux/
:imagesdir: ../image/

// 只有book调用的时候才会走到这里
ifdef::rootpath[]
:imagesdir: {rootpath}{path}{imagesdir}
endif::rootpath[]

== 系统知识

=== PC系统架构

[[PCSystem]]
image::image-2022-07-02-10-29-44-536.png[PC系统架构]

=== 一个程序的执行过程

[plantuml, diagram=helloworld-exec,format=png]
....
编译器 : ccl
汇编器 : as
链接器 : ld

[*] -> 预处理起 : hello.c
预处理起 -> 编译器 : hello.i
编译器 -> 汇编器 : hello.s
汇编器 -> 链接器 :  hello.o
链接器 -> [*] : hello
....

[IMPORTANT]
处理器的核心就是PC寄存器，用来存储计算机下一步需要执行的指令

<<PCSystem, 程序执行过程>>
假如有一个可执行程序hello, 正常程序是存储在磁盘的中的，当需要执行时，系统会将程序加载到内存中(主内存中)，当处理器开始执行程序hello时，会将指令通过寄存器送往运算单元，并将需要打印的字符等通过寄存器复制到现实设备


== ARM


=== ARM寄存器以及工作模式

image::image-2022-07-02-10-56-42-650.png[ARM处理器以及工作模式]

ARM在实际工作中，各个模式之间会相互切换，其中比较特殊的事FIQ，因为FIQ拥有的寄存器比较多，又因为FIQ的响应优先级比较高，因此FIQ能能更快的切换状态。

1. R0-R12是通用寄存器，放通用数据
2. 各个模式R0-R12与User模式是共享的除了FIQ(F8-F12自有)，PC CPSR共享
3. User模式没有SPSR














==== 什么是大小端

小端(Little-endian)：就是低字节排放在内存的的低地址端，高位字节排放到内存的高地址端 +
大端(Big-endian)：就是高位字节排放在内存的低地址端，低字节排放到内存的高地址端

[TIP]
1)大端模式：
低地址 -----------------> 高地址
0x12  |  0x34  |  0x56  |  0x78
2)小端模式：
低地址 ------------------> 高地址
0x78  |  0x56  |  0x34  |  0x12

判断系统大小端

.BgiEndian.cpp
[source, cpp]
----
bool BigEndian()
{
    union
    {
        uint16_t a;
        char b;
    }num;
    num.a = 0x1234;
    if(num.b == 0x12)
    {
        return true;
    }
    return false;
}
----






=== 文件IO









=== 进程间通信







=== 线程间同步







=== 守护进程

















=== 内存管理

Linux内存管理，内存寻址，虚拟内存，内存调页算法，任务调度算法

[TIP]
Linux虚拟内存实现需要6种机制支持：地址映射机制、内存分配回收机制、缓存和刷新机制、请求页机制、交换机机制、内存共享机制

内存管理程序通过映射机制(MMU)可以把用户程序的逻辑地址映射到物理地址。当用户程序运行时，如果发现程序中的虚拟地址没有对应的物理地址，就发出请求页的请求，如果有空闲的内存可供分配，就请求分配内存(此处需要内存的分配和回收机制)，并把使用的物理页记录到缓存中(使用了缓存机制)。如果没有足够的内存可供分配，那么就调用交换机制，腾出一部分内存。另外在地址映射中要通过TLB(翻译后缓存储器)来寻找物理页；交换机知中也要用到交换缓存，并且把物理页内容交换到文件中，也要修改页表来映射文件地址。





=== 信号
常见的信号？ 操作系统如何将一个信号通知到进程

[source, bash]
----
andrew@andrew-G3-3590:~$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX
----
信号是进程之间传递消息的一种方法，信号全称为软中断信号，当然有诶有些人称作软中断 +
进程间可以通过调用系统调用kill发送信号，
[red]#几种常见的信号#：

[source, bash]
----
SIGHUP 1 A 终端挂起或者控制进程终止
SIGINT 2 A 键盘中断（如break键被按下）
SIGQUIT 3 C 键盘的退出键被按下
SIGILL 4 C 非法指令
SIGABRT 6 C 由abort(3)发出的退出指令
SIGFPE 8 C 浮点异常
SIGKILL 9 AEF Kill信号
SIGSEGV 11 C 无效的内存引用
SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道
----


=== 在线编译工具

https://www.godbolt.org[在线编译工具]





=== qemu 内核调试

www.kernel.org内核地址


https://www.bilibili.com/read/cv11271232 教程











